#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Apr 21 14:41:44 2022
@author: Richard Frazin

Cubic B-Spline utilities

I could not get scipy.interpolate.LSQBivariateSpline to work
"""


import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
from scipy.stats import norm

"""
cubic b-spline functions
See M. Unser, IEEE Sig. Proc. Mag., Nov. 1999
This assumes the knots are uniformly spaced,
  which makes them cardinal b-splines.

this evaluates the 1D cubic b-spline at x
delta is the spacing between the spline knots.
The resulting function is nonzero for |x/delta| < 2
"""
def Bspline3_1D_vec(x, delta): # this is faster than  Bspline3_1D
    q = np.abs(x / delta)
    out = np.zeros_like(q)
    mask1 = q < 1
    mask2 = (q >= 1) & (q < 2)
    out[mask1] = 2/3 - q[mask1]**2 + 0.5 * q[mask1]**3
    out[mask2] = ((2 - q[mask2])**3) / 6
    return out

def Bspline3_2D_vector(x, y, delta):  # faster than Bspline3_2D_vector
    return Bspline3_1D_vec(x, delta) * Bspline3_1D_vec(y, delta)


def Bspline3_1D(x, delta):
    assert np.isscalar(x)
    assert np.isscalar(delta)
    q = np.abs(x/delta)
    if q >= 2.:
        return(0.)
    if q >= 1.:
        return( ((2.-q)**3)/6. )
    else:
        return( (2./3 - q*q + q*q*q/2.))

def Bspline3_2D(x, y, delta):  #the above functions are faster
    bx = Bspline3_1D(x, delta)
    by = Bspline3_1D(y, delta)
    return(bx*by)
def __Bspline3_2D_vector(x,y,delta):  # this assumes x and y are generated by the np.meshgrid routine
    assert x.ndim == 2 and y.ndim == 2
    assert x.shape == y.shape
    z = np.zeros((x.shape))
    for kx in range(x.shape[1]):
        for ky in range(x.shape[0]):
            z[ky,kx] = Bspline3_2D(x[ky,kx],y[ky,kx], delta)
    return(z)


"""
Class for bivariate b-spline regression.
This assumes the same spacing of the spline knots in both directions on a rectanglular
  grid of knots.  There is a spline centered on every knot.  Note that in 1D, a given spline
  fcn centered at knot n, located at x_n, has support between x_{n-2} and x_{n+2}.
  Therefore, a point located bewteen x_n and x_{n+1} is within the support of the splines
  [n-1, n, n+1, n+2].  Thus, in 2D, there are up to 16 splines to consider for a given pont.

z - 1D vector of function values to be fit (not needed for __init__() )
x - 1D vector of x coords corresponding to z.  must have len(x) == len(z)
y - 1D vector of y coords corresponding to z.  must have len(y) == len(x)
    -- x and y are likely the output of the np.meshgrid routine
Nx - number of spline knots in x-direction
Xmin - location (x coordinate) of leftmost spline knot
Delta - distance (1D) between spline knots (same in both directions)
Ny - number of splne knots in y-direction. if None -> Ny = Nx
Ymin - location (y coordinate) of bottom spline knot. if None -> Ymin = Xmin
Normalize - if True, basis functions sum to unity
ZeroMean - spline functions are zero-mean, except at the edges.
           This adds another coefficient (the final one!) representing the mean of the function
reg - regularization parameter (Tikhonov).  if None -> truncated SVD is applied
KnotsOnly - Don't calculate the matrices, just set things up.
"""

### begin  class definition
class BivariateCubicSpline():  #
    def __init__(self, x, y, Nx, Xmin=None, Delta=None, Ny=None, Ymin=None, reg=None,
                 Normalize=False, ZeroMean=False, KnotsOnly=False):
        assert np.array(x).ndim == np.array(y).ndim ==  1
        assert len(x) == len(y)
        if Delta is None:
            Delta = (x.max() - x.min())/Nx
        self.Delta = Delta
        self.x = x; self.y = y
        if Ny == None: Ny = Nx
        if Xmin is None:
            Xmin = x.min() + Delta/2.
        if Ymin == None: Ymin = Xmin
        self.Xmin = Xmin; self.Ymin = Ymin; self.Nx=Nx; self.Ny=Ny
        self.Nsp = Nx*Ny  # total number of splines
        if ZeroMean:
            self.Nsp += 1
            print("Using the ZeroMean kwarg is a bad idea.  It makes the matrix singular.")
            assert(False)
        self.twoTOone = dict()  # dictionary from 2D index to 1D index of spline knots
        self.oneTOtwo = dict()  # dictionary from 1D index to 2D index of spline knots
        self.splcen   = dict()  # dictionary of spline centers (note the two key types, as per below)
        k = -1
        for ky in range(Ny):
            for kx in range(Nx):
                k += 1
                self.oneTOtwo[k] = (kx, ky)
                self.twoTOone[(kx, ky)] = k
                self.splcen[k] = (Xmin + kx*Delta, Ymin + ky*Delta)
                self.splcen[(kx, ky)] = (Xmin + kx*Delta, Ymin + ky*Delta)
        if KnotsOnly:  # don't calculate the matrices
            self.mat = None; self.imat = None; self.eigvals = None
            return(None)

        mat = np.zeros((len(x), self.Nsp)).astype('float32')  # the spline coefficients come from inverting this matrix
        for k in range(len(x)):
            mx = np.floor( (x[k] - Xmin)/Delta ).astype('int')  # x[k] is between mx and mx+1
            my = np.floor( (y[k] - Ymin)/Delta ).astype('int')  # y[k] is between my and my+1
            for ky in range(my-1, my+3):
                if (ky > -1) and (ky < Ny):
                    for kx in range(mx-1, mx+3):
                        if (kx > -1 ) and (kx < Nx):
                            kn = self.twoTOone[(kx,ky)]  # 1D knot index
                            dx = x[k] - self.splcen[(kx,ky)][0]
                            dy = y[k] - self.splcen[(kx,ky)][1]
                            mat[k, kn] = Bspline3_2D(dx, dy, Delta)
                        else:  pass  # condition on kx
                else: pass  # condition on ky
        if Normalize:
            kn = self.twoTOone[(self.Nx//2, self.Ny//2)]
            mat /= np.sum(mat[:,kn])
        if ZeroMean:
            kn = self.twoTOone[(self.Nx//2, self.Ny//2)]
            meanSpVal = np.sum(mat[:,kn])/np.count_nonzero(mat[:,kn])
            mat -= meanSpVal
            mat[:, -1] = np.ones((len(x),))/len(x)  # final column corresponds to the mean
        self.mat = mat


        #w is a vector of eigenvalues, the columns of V are the corresponding eigenvectors
        #V.dot(np.diag(w)).dot(V.T) = mat.T.dot(mat)
        #V.dot(V.T) is the identity
        #V.dot(np.inv(np.diag(w))).dot(V.T) = np.inv(mat.T.dot(mat))  if there are no zero eigenvalues
        w, V = np.linalg.eigh(mat.T.dot(mat))
        self.eigvals = w
        nz = len(w) - np.count_nonzero(w)
        if nz == 0:  #no zero eigenvalues
            print("The regression matrix has no zero eigenvalues, and the condition number is ",
                  np.max(w)/np.min(w), "  The eigenvalues are stored in .eigvals" )
        else:
            print("The regression matrix has ", nz, " zero eigenvalues.  The eigenvalues are stored in .eigvals")

        print("The forward matrix is stored in .mat and its pseudo-inverse is stored in .imat")
        if reg is None:
            print("You have chosen not to apply regularization.")
            if nz == 0:
                self.imat = V.dot(np.diag(1/w)).dot(V.T).dot(mat.T)
            else:
                self.imat = np.linalg.pinv(mat)
        else:
            print("You have chosen to apply regularization with parameter ", reg)
            self.imat = np.linalg.inv(mat.T.dot(mat) + reg*np.eye(self.Nsp)).dot(mat.T)
        return(None)

    #This gets the spline coefficients for a given set of observations
    # z is flattened array of observations
    #Works for complex z
    def GetSplCoefs(self, z):
        assert np.array(z).ndim == 1
        assert len(z) == len(self.x)
        return(self.imat.dot(z))

    #Given a set of spline coefs (see GetSplCoefs() ), this provides the interpolation.
    #coefs - a vector of spline coefficients - can be complex (See .GetSplCoefs)
    #xi - if None: self.x and self.y will be used for the spatial grid
    #     if not None: a flattened array (or list) of x coordinates (see np. meshgrid)
    #yi - a flattened array (or list) of y coordinates (if not None)
    #Works for complex valued coefs vector
    def SplInterp(self, coefs, xi=None, yi=None):
        if len(coefs) != self.Nsp:
            print("usage: .SplInterp(coefs, xi=[None], yi=[None])");
            assert(False)
        if xi is None:
            assert(yi is None)
            return self.mat.dot(coefs)
        else:
            assert(yi is not None)
            assert np.array(xi).ndim == np.array(yi).ndim == 1
            assert len(xi) == len(yi)
            if np.iscomplexobj(coefs):
                out = np.zeros((len(xi), )).astype('complex')  # output values
            else:
                out = np.zeros((len(xi), ))  # output values
            for k in range(len(xi)):
                mx = np.floor( (xi[k] - self.Xmin)/self.Delta ).astype('int')  # xi[k] is between mx and mx+1
                my = np.floor( (yi[k] - self.Ymin)/self.Delta ).astype('int')  # yi[k] is between my and my+1
                for ky in range(my-1, my+3):
                    if (ky > -1) and (ky < self.Ny):
                        for kx in range(mx-1, mx+3):
                            if (kx > -1 ) and (kx < self.Nx):
                                kn = self.twoTOone[(kx,ky)]  # 1D knot index
                                dx = xi[k] - self.splcen[(kx,ky)][0]
                                dy = yi[k] - self.splcen[(kx,ky)][1]
                                out[k] += coefs[kn]*Bspline3_2D(dx, dy, self.Delta)
                            else:  pass  # condition on kx
                    else: pass  # condition on ky
            return(out)
### end class definition

class UnivariateCubicSpline():  #
    def __init__(self, x, Nx, Xmin=None, Delta=None, reg=None,
                 Normalize=False, ZeroMean=False, KnotsOnly=False):
        assert np.array(x).ndim ==  1
        if Delta is None:
            Delta = (x.max() - x.min())/Nx
        if Xmin is None:
            Xmin = x.min() + Delta/2
        self.Delta = Delta
        self.Nsp = Nx
        self.x = x;
        self.Xmin = Xmin;
        self.Nx=Nx;
        if ZeroMean:
            self.Nsp += 1
            print("Using the ZeroMean kwarg is a bad idea.  It makes the matrix singular.")
            assert(False)
        self.splcen   = dict()  # dictionary of spline centers (note the two key types, as per below)
        k = -1
        for kx in range(Nx):
                k += 1
                self.splcen[k] = Xmin + kx*Delta
        if KnotsOnly:  # don't calculate the matrices
            self.mat = None; self.imat = None; self.eigvals = None
            return(None)

        mat = np.zeros((len(x), self.Nsp)).astype('float32')  # the spline coefficients come from inverting this matrix
        for k in range(len(x)):
            mx = np.floor( (x[k] - Xmin)/Delta ).astype('int')  # x[k] is between mx and mx+1
            for kx in range(mx-1, mx+3):
                        if (kx > -1 ) and (kx < Nx):
                            kn = kx  # 1D knot index
                            dx = x[k] - self.splcen[kx]
                            mat[k, kn] = Bspline3_1D(dx, Delta)
                        else:  pass  # condition on kx
        if Normalize:
            kn = self.twoTOone[(self.Nx//2, self.Ny//2)]
            mat /= np.sum(mat[:,kn])
        if ZeroMean:
            kn = self.twoTOone[(self.Nx//2, self.Ny//2)]
            meanSpVal = np.sum(mat[:,kn])/np.count_nonzero(mat[:,kn])
            mat -= meanSpVal
            mat[:, -1] = np.ones((len(x),))/len(x)  # final column corresponds to the mean
        self.mat = mat


        #w is a vector of eigenvalues, the columns of V are the corresponding eigenvectors
        #V.dot(np.diag(w)).dot(V.T) = mat.T.dot(mat)
        #V.dot(V.T) is the identity
        #V.dot(np.inv(np.diag(w))).dot(V.T) = np.inv(mat.T.dot(mat))  if there are no zero eigenvalues
        w, V = np.linalg.eigh(mat.T.dot(mat))
        self.eigvals = w
        nz = len(w) - np.count_nonzero(w)
        if nz == 0:  #no zero eigenvalues
            print("The regression matrix has no zero eigenvalues, and the condition number is ",
                  np.max(w)/np.min(w), "  The eigenvalues are stored in .eigvals" )
        else:
            print("The condition matrix has ", nz, " zero eigenvalues.  The eigenvalues are stored in .eigvals")

        print("The forward matrix is stored in .mat and its pseudo-inverse is stored in .imat")
        if reg is None:
            print("You have chosen not to apply regularization.")
            if nz == 0:
                self.imat = V.dot(np.diag(1/w)).dot(V.T).dot(mat.T)
            else:
                self.imat = np.linalg.pinv(mat)
        else:
            print("You have chosen to apply regularization with parameter ", reg)
            self.imat = np.linalg.inv(mat.T.dot(mat) + reg*np.eye(self.Nsp)).dot(mat.T)
        return(None)

    #This gets the spline coefficients for a given set of observations
    # z is flattened array of observations
    #Works for complex z
    def GetSplCoefs(self, z):
        assert np.array(z).ndim == 1
        assert len(z) == len(self.x)
        return(self.imat.dot(z))

    #Given a set of spline coefs (see GetSplCoefs() ), this provides the interpolation.
    #coefs - a vector of spline coefficients - can be complex (See .GetSplCoefs)
    #xi - if None: self.x and self.y will be used for the spatial grid
    #     if not None: a flattened array (or list) of x coordinates (see np. meshgrid)
    #yi - a flattened array (or list) of y coordinates (if not None)
    #Works for complex valued coefs vector
    def SplInterp(self, coefs, xi=None):
        if len(coefs) != self.Nsp:
            raise Exception("usage: .SplInterp(coefs, xi=[None])");
        if xi is None:
            return self.mat.dot(coefs)
        else:
            if np.iscomplexobj(coefs):
                out = np.zeros((len(xi), )).astype('complex')  # output values
            else:
                out = np.zeros((len(xi), ))  # output values
            for k in range(len(xi)):
                mx = np.floor( (xi[k] - self.Xmin)/self.Delta ).astype('int')  # xi[k] is between mx and mx+1
                for kx in range(mx-1, mx+3):
                            if (kx > -1 ) and (kx < self.Nx):
                                kn = kx
                                dx = xi[k] - self.splcen[kx]
                                out[k] += coefs[kn]*Bspline3_1D(dx, self.Delta)
                            else:  pass  # condition on kx
            return(out)
    #This fits the 1D CBS function to a standard Normal and plots the result
    def Fit_Spline_To_Normal(self):
      def spline_model(x, A, delta):  # Vectorized version for fitting
          return np.array([A * Bspline3_1D(xi, delta) for xi in x])

      # Generate data from the standard normal distribution
      x_fit = np.linspace(-3, 3, 1121)
      y_target = norm.pdf(x_fit)

      # Fit parameters A and delta
      initial_guess = [0.6, 1.666666]
      popt, pcov, info = curve_fit(spline_model, x_fit, y_target, p0=initial_guess, full_output=True)
      A_fit, delta_fit = popt
      print(f"Fitted parameters:\n  A     = {A_fit:.6f}\n  delta = {delta_fit:.6f}")

      # Plot over range [-2.2 delta, 2.2 delta]
      x_plot = np.linspace(-2.2 * delta_fit, 2.2 * delta_fit, 1000)
      y_spline = spline_model(x_plot, A_fit, delta_fit)
      y_gauss = norm.pdf(x_plot)

      # Plotting
      plt.figure(figsize=(8, 5))
      plt.plot(x_plot, y_gauss, 'k--', label='Standard Normal')
      plt.plot(x_plot, y_spline, 'b-', label='Fitted Cubic B-Spline')
      plt.xlabel('x')
      plt.ylabel('Density')
      plt.title('Cubic B-Spline Fit to Standard Normal')
      plt.legend()
      plt.grid(True)
      plt.tight_layout()
      plt.show()
      #the result is delta =
      #make a log y plot


### end class definition


#This illustrates how to use these spline tools
def Example():
    z = np.kron(np.random.rand(10,10),np.ones((5,5)));  # object to be fit
    s = np.linspace(0,1,50); x, y = np.meshgrid(s,s)
    nsp = 10; Xmin=0.05; Delta=0.1;
    bs = BivariateCubicSpline(x.flatten(), y.flatten(), nsp, Xmin, Delta)
    return(bs)

#This provides examples of representing big spline functions on smaller ones
#It works nicely when the smaller spines have a knot exactly over the center
# of the original
def MultiResExample():
    bdelt = 0.1;
    s = np.linspace(-4*bdelt, 4*bdelt,51)
    x,y = np.meshgrid(s,s)
    z = Bspline3_2D_vector(x,y,bdelt)
    delt = bdelt/2.
    nsp = np.round(8*bdelt/delt).astype('int');
    if np.mod(nsp,2) == 0: nsp += 1
    start = - delt*(nsp//2)
    spl = BivariateCubicSpline(x.flatten(),y.flatten(),nsp,start,delt)
    coef = spl.GetSplCoefs(z.flatten())
    zs = spl.SplInterp(x.flatten(),y.flatten(),coef)
    zs = zs.reshape((x.shape))


    return(None)
